# Контрольные вопросы

## Списки

### Как создать пустой список в Python?
```python
# Способ 1
empty_list = []

# Способ 2
empty_list = list()
```

### Как добавить элемент в конец списка?
```python
my_list = [1, 2, 3]
my_list.append(4)  # my_list теперь [1, 2, 3, 4]
```

### Как удалить элемент по значению из списка?
```python
my_list = [1, 2, 3, 4]
my_list.remove(3)  # my_list теперь [1, 2, 4]
```

### Какой метод возвращает количество вхождений элемента в списке?
```python
my_list = [1, 2, 3, 2, 4, 2]
count = my_list.count(2)  # count = 3
```

### Как использовать метод extend() в списках, и чем он отличается от append()?
```python
# extend() добавляет все элементы из итерируемого объекта в конец списка
list1 = [1, 2, 3]
list2 = [4, 5, 6]
list1.extend(list2)  # list1 теперь [1, 2, 3, 4, 5, 6]

# append() добавляет один элемент в конец списка
list3 = [1, 2, 3]
list4 = [4, 5, 6]
list3.append(list4)  # list3 теперь [1, 2, 3, [4, 5, 6]]
```

### Как получить индекс первого вхождения элемента в списке?
```python
my_list = [10, 20, 30, 20, 40]
index = my_list.index(20)  # index = 1
```

### Как можно получить доступ к элементу во вложенном списке?
```python
nested_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
element = nested_list[1][2]  # element = 6
```

### Как можно изменить элемент во вложенном списке?
```python
nested_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
nested_list[1][2] = 60  # nested_list теперь [[1, 2, 3], [4, 5, 60], [7, 8, 9]]
```

## Кортежи

### Чем кортежи отличаются от списков?
Кортежи, в отличие от списков, являются неизменяемыми (иммутабельными) структурами данных. После создания кортежа его элементы нельзя изменить, добавить или удалить. Кортежи обычно используются для хранения коллекций данных, которые не должны изменяться.

### Как создать кортеж с одним элементом?
```python
# Обязательно нужна запятая после элемента
single_tuple = (42,)

# Или так
single_tuple = 42,
```

### Можете ли вы изменить элемент кортежа?
Нет, кортежи являются неизменяемыми (иммутабельными). После создания кортежа его элементы нельзя изменить.

### Какие методы есть у кортежей?
У кортежей есть всего два метода:
```python
my_tuple = (1, 2, 3, 2, 4)
my_tuple.count(2)  # Возвращает количество вхождений элемента (результат: 2)
my_tuple.index(3)  # Возвращает индекс первого вхождения элемента (результат: 2)
```

### Какие функции есть у кортежей?
Кортежи поддерживают все стандартные функции для последовательностей:
```python
my_tuple = (1, 2, 3, 4, 5)
len(my_tuple)  # Возвращает длину кортежа
max(my_tuple)  # Возвращает максимальное значение
min(my_tuple)  # Возвращает минимальное значение
sum(my_tuple)  # Возвращает сумму элементов
sorted(my_tuple)  # Возвращает отсортированный список (не кортеж!)
tuple([1, 2, 3])  # Преобразует итерируемый объект в кортеж
```

### Как работаю срезы у списков и кортежей?
Срезы работают одинаково для списков и кортежей:
```python
my_list = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
my_tuple = (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)

# Базовый синтаксис: sequence[start:stop:step]
# Получение элементов с индекса 2 по 5 (не включая 6)
list_slice = my_list[2:6]  # [2, 3, 4, 5]
tuple_slice = my_tuple[2:6]  # (2, 3, 4, 5)

# С шагом 2
list_slice = my_list[1:8:2]  # [1, 3, 5, 7]
tuple_slice = my_tuple[1:8:2]  # (1, 3, 5, 7)

# Отрицательные индексы (с конца)
list_slice = my_list[-3:]  # [7, 8, 9]
tuple_slice = my_tuple[-3:]  # (7, 8, 9)

# Обратный порядок
list_slice = my_list[::-1]  # [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
tuple_slice = my_tuple[::-1]  # (9, 8, 7, 6, 5, 4, 3, 2, 1, 0)
```

## Словари

### Как создать пустой словарь в Python?
```python
# Способ 1
empty_dict = {}

# Способ 2
empty_dict = dict()
```

### Как добавить новую пару «ключ-значение» в словарь?
```python
my_dict = {'a': 1, 'b': 2}
my_dict['c'] = 3  # my_dict теперь {'a': 1, 'b': 2, 'c': 3}
```

### Как получить значение по ключу из словаря?
```python
my_dict = {'a': 1, 'b': 2, 'c': 3}
value = my_dict['b']  # value = 2
```

### Как удалить элемент из словаря по ключу?
```python
my_dict = {'a': 1, 'b': 2, 'c': 3}
del my_dict['b']  # my_dict теперь {'a': 1, 'c': 3}

# Или с помощью метода pop
value = my_dict.pop('c')  # value = 3, my_dict теперь {'a': 1}
```

### Какой метод в словарях позволяет получить значение по ключу с заданием значения по умолчанию?
```python
my_dict = {'a': 1, 'b': 2}
value = my_dict.get('c', 0)  # Если ключа 'c' нет, вернется 0
```

### Как получить список всех ключей и значений в словаре?
```python
my_dict = {'a': 1, 'b': 2, 'c': 3}
keys = list(my_dict.keys())  # ['a', 'b', 'c']
values = list(my_dict.values())  # [1, 2, 3]
items = list(my_dict.items())  # [('a', 1), ('b', 2), ('c', 3)]
```

### Как можно получить доступ к значению во вложенном словаре?
```python
nested_dict = {
    'person': {
        'name': 'Иван',
        'age': 30,
        'contacts': {
            'email': 'ivan@example.com',
            'phone': '123-456-789'
        }
    }
}

email = nested_dict['person']['contacts']['email']  # email = 'ivan@example.com'
```

### Как добавить новый элемент во вложенный словарь?
```python
nested_dict = {
    'person': {
        'name': 'Иван',
        'contacts': {
            'email': 'ivan@example.com'
        }
    }
}

nested_dict['person']['contacts']['phone'] = '123-456-789'
# Теперь nested_dict['person']['contacts'] = {'email': 'ivan@example.com', 'phone': '123-456-789'}
```

## Множества

### Как создать пустое множество в Python?
```python
# Правильный способ
empty_set = set()

# Неправильный способ (создаст словарь, а не множество)
not_a_set = {}  # Это создаст пустой словарь, а не множество
```

### Как добавить элемент в множество?
```python
my_set = {1, 2, 3}
my_set.add(4)  # my_set теперь {1, 2, 3, 4}
```

### Какова разница между множеством и списком?
1. Множества содержат только уникальные элементы, а списки могут содержать дубликаты.
2. Множества не сохраняют порядок элементов, а списки сохраняют.
3. Элементы множества должны быть хешируемыми (неизменяемыми), а элементы списка могут быть любыми.
4. Множества оптимизированы для проверки наличия элемента (операция `in` работает за O(1)).
5. Множества поддерживают математические операции: объединение, пересечение, разность и т.д.

### Какие методы множеств для чего используются?
```python
a = {1, 2, 3}
b = {3, 4, 5}

# Добавление элемента
a.add(4)  # a теперь {1, 2, 3, 4}

# Удаление элемента (вызывает ошибку, если элемента нет)
a.remove(4)  # a теперь {1, 2, 3}

# Удаление элемента (не вызывает ошибку, если элемента нет)
a.discard(4)  # a остается {1, 2, 3}

# Удаление и возврат произвольного элемента
element = a.pop()  # element может быть 1, 2 или 3

# Объединение множеств
c = a.union(b)  # c = {1, 2, 3, 4, 5}
# или c = a | b

# Пересечение множеств
d = a.intersection(b)  # d = {3}
# или d = a & b

# Разность множеств
e = a.difference(b)  # e = {1, 2}
# или e = a - b

# Симметрическая разность
f = a.symmetric_difference(b)  # f = {1, 2, 4, 5}
# или f = a ^ b

# Проверка, является ли множество подмножеством
a.issubset({1, 2, 3, 4})  # True

# Проверка, является ли множество надмножеством
a.issuperset({1, 2})  # True

# Проверка, не пересекаются ли множества
a.isdisjoint({4, 5})  # True
```

### Какой метод позволяет удалить все элементы из множества?
```python
my_set = {1, 2, 3, 4}
my_set.clear()  # my_set теперь пустое множество set()
```

## Дополнительные структуры данных

### Что такое defaultdict и как он работает?
`defaultdict` - это подкласс словаря из модуля `collections`, который предоставляет значение по умолчанию для несуществующих ключей, вместо того чтобы вызывать ошибку.

```python
from collections import defaultdict

# Создание defaultdict с типом list в качестве значения по умолчанию
d = defaultdict(list)
d['a'].append(1)  # Автоматически создается пустой список для ключа 'a'
d['a'].append(2)  # d теперь {'a': [1, 2]}

# Создание defaultdict с типом int в качестве значения по умолчанию
word_count = defaultdict(int)
for word in ['apple', 'banana', 'apple', 'orange', 'banana', 'apple']:
    word_count[word] += 1  # Автоматически инициализирует счетчик с 0
# word_count теперь {'apple': 3, 'banana': 2, 'orange': 1}
```

### Как создать Counter из списка элементов?
```python
from collections import Counter

# Создание Counter из списка
fruits = ['apple', 'banana', 'apple', 'orange', 'banana', 'apple']
fruit_counter = Counter(fruits)
# fruit_counter теперь Counter({'apple': 3, 'banana': 2, 'orange': 1})

# Получение наиболее часто встречающихся элементов
most_common = fruit_counter.most_common(2)  # [('apple', 3), ('banana', 2)]
```

### В чем преимущество использования namedtuple по сравнению с обычными кортежами?
`namedtuple` из модуля `collections` позволяет создавать кортежи с именованными полями, что делает код более читаемым и понятным.

```python
from collections import namedtuple

# Определение нового типа namedtuple
Person = namedtuple('Person', ['name', 'age', 'city'])

# Создание экземпляра
person = Person('Иван', 30, 'Москва')

# Доступ к полям по имени (более читаемо)
print(person.name)  # 'Иван'
print(person.age)   # 30
print(person.city)  # 'Москва'

# Также можно обращаться по индексу, как в обычном кортеже
print(person[0])    # 'Иван'
```

Преимущества `namedtuple`:
1. Более читаемый код благодаря доступу к полям по имени
2. Самодокументируемый код (имена полей описывают их назначение)
3. Неизменяемость (как и обычные кортежи)
4. Поддержка всех методов кортежей
5. Более компактное хранение данных по сравнению с классами
